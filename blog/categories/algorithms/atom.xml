<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithms | Donovan Whitworth]]></title>
  <link href="http://dwhitworth.github.io/blog/categories/algorithms/atom.xml" rel="self"/>
  <link href="http://dwhitworth.github.io/"/>
  <updated>2014-08-18T22:26:34-07:00</updated>
  <id>http://dwhitworth.github.io/</id>
  <author>
    <name><![CDATA[Donovan Whitworth]]></name>
    <email><![CDATA[donovan.whitworth@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SQL Is Your Friend]]></title>
    <link href="http://dwhitworth.github.io/blog/2014/04/26/sql-is-your-friend/"/>
    <updated>2014-04-26T16:36:52-07:00</updated>
    <id>http://dwhitworth.github.io/blog/2014/04/26/sql-is-your-friend</id>
    <content type="html"><![CDATA[<p>Our final project for MakerSquare was crowd-funding platform for public dares, challenges and acts of kindness. You can check it out here: <a href="http://we-dare-you.herokuapp.com">we-dare-you.herokuapp.com</a>. Every dare had multiple monetary contributions and we would sum up those contributions via a &ldquo;pot_size&rdquo; method. <!-- more --></p>

<p>When summing up multiple elements in an array, our go to method is Ruby&rsquo;s <code>inject</code> method, but sometimes we forget that SQL has some built in functionality that may be faster and ease the load on memory.</p>

<p>We had 8 models with quite a few associations, but let&rsquo;s concentrate on two models:</p>

<p>```ruby
class Dare &lt; ActiveRecord::Base
  has_many :contributions
  # &hellip;
end</p>

<p>class Contribution &lt; ActiveRecord::Base
  belongs_to :dare
  # &hellip;
end
```</p>

<p>So, to get a pot size for a specific dare, we made a method that looked something like this:</p>

<p><code>ruby
def pot_size
  self.contributions.inject(0) {| total, contribution | total + contribution.amount }.to_f / 100
end
</code></p>

<p>This should be refactored to:</p>

<p><code>ruby
def pot_size
  self.contributions.map(&amp;:amount).inject(:+).to_f / 100
end
</code></p>

<p>Using this method, we use the has_many association to get all the contributions for a specific dare. The SQL generated looks something like this:</p>

<p><code>SELECT &ldquo;amount&rdquo;.* FROM &ldquo;contributions&rdquo; WHERE &ldquo;contributions&rdquo;.&ldquo;dare_id&rdquo; = &lt;dare_id></code></p>

<p>I seeded a database with 100,000 test contributions and the above method took 1.6 seconds and change. The SQL statement above is finding all the contributions and putting them into memory before adding up the amounts.</p>

<p>A much more efficient way is to use SQL to do the work of summing the amounts. It will be much faster and use much less memory. We can refactor the &ldquo;pot_size&rdquo; method to look more like this:</p>

<p><code>ruby
def pot_size
  self.contributions.sum(:amount).to_f / 100
end
</code></p>

<p>It generated SQL that looked like this:</p>

<p><code>SELECT SUM(&ldquo;contributions&rdquo;.&ldquo;amount&rdquo;) AS sum_id FROM &ldquo;contributions&rdquo; WHERE &ldquo;contributions&rdquo;.&ldquo;dare_id&rdquo; = &lt;dare_id></code></p>

<p>Using the above method, we avoid pulling all those records into memory and let SQL sum up the amounts in one step. The above method took 17ms!</p>

<p>The moral of the story is you don&rsquo;t <em>always</em> have to use Ruby methods when manipulating your ActiveRecord objects, sometimes good old SQL is faster and uses less memory.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby: counting duplicates in an array with inject]]></title>
    <link href="http://dwhitworth.github.io/blog/2014/02/16/counting-duplicates-in-an-array-with-inject/"/>
    <updated>2014-02-16T17:29:43-08:00</updated>
    <id>http://dwhitworth.github.io/blog/2014/02/16/counting-duplicates-in-an-array-with-inject</id>
    <content type="html"><![CDATA[<p>Earlier this week we were tasked with calculating the most and least popular colors, given an array of car objects. <!-- more -->We started with this array:</p>

<p><code>ruby
@cars = []
3.times { @cars &lt;&lt; Car.new('black') }
5.times { @cars &lt;&lt; Car.new('silver') }
2.times { @cars &lt;&lt; Car.new('white') }
</code></p>

<p>We needed to make methods that would return the most popular color (5 silver cars) and the least popular (2 white cars). The first thing I did was make a new array from the array of car objects (using the .map method) populated with just colors. Like this:</p>

<p><code>ruby
@colors = @cars.map { |car| car.color }
</code>
If you puts that array it would look like this:
<code>ruby
["black", "black", "black", 'silver', 'silver', 'silver', 'silver', 'silver', "white", "white"]
</code></p>

<p>So, now how do you get a count of all items in that array, incremented every time you hit a duplicate?</p>

<p>.inject</p>

<p>First, let&rsquo;s talk about .inject. Ruby docs says .inject:</p>

<blockquote><p>Combines all elements of enum by applying a binary operation, specified by a block or a symbol that names a method or operator.</p>

<p>If you specify a block, then for each element in enum the block is passed an accumulator value and the element. At the end of the iteration, the final value of memo is the return value for the method.</p></blockquote>

<p>whaahuhhh?</p>

<p>Well, let&rsquo;s break it down by using the classic example of .inject. To obtain a sum of each element in an array you could do this:
<code>ruby
[1,2,3,4,5].inject(0) { |item, element| item + element } # =&gt; 15
</code>
The argument you pass into <code>.inject(0)</code> is then passed into the <code>item</code> variable, which is then added to the first <code>element</code> in the array. Then the return value of the block is passed back into the block as <code>item</code>. This is done for each element in the array, leaving you with a sum of the numbers.</p>

<p>So, back to our array of colors. How do I turn that into <code>{&ldquo;black&rdquo; => 3, &ldquo;silver&rdquo; => 5, &ldquo;white&rdquo; => 2}</code>?</p>

<p>Well, if I use <code>Hash.new(0)</code> as the first accumulator value, that will make a new hash and the default values for each key you pass in will be 0. Then, everytime I pass a duplicate into that hash, I just increment the value for that given key, then return the entire hash back into the accumulator. Like this:</p>

<p>```ruby
@frequency = @colors.inject(Hash.new(0)) do |hash, key|</p>

<pre><code>hash[key] += 1
hash
end
</code></pre>

<p>```</p>

<p>So, for each element of the @colors array, we inject a hash with the element becoming the key, and everytime that key is passed into the block, we increment the value. Voila!
<code>
{"black" =&gt; 3, "silver" =&gt; 5, "white" =&gt; 2}
</code>
Now I can access the lowest and/or highest values in the array using the <code>min_by</code> or <code>max_by</code> methods for a hash.</p>

<p>Until next time&hellip;</p>

<blockquote><p>If you end up with a boring miserable life because you listened to your mom, your dad, your teacher, your priest, or some guy on television telling you how to do your shit, then you deserve it.</p>

<p>- Frank Zappa</p></blockquote>
]]></content>
  </entry>
  
</feed>
