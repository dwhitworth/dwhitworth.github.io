<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Donovan Whitworth]]></title>
  <link href="http://dwhitworth.github.io/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://dwhitworth.github.io/"/>
  <updated>2014-08-19T13:34:00-07:00</updated>
  <id>http://dwhitworth.github.io/</id>
  <author>
    <name><![CDATA[Donovan Whitworth]]></name>
    <email><![CDATA[donovan.whitworth@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby: The absolutely 100% wrong way to define a method]]></title>
    <link href="http://dwhitworth.github.io/blog/2014/08/18/ruby-the-absolutely-100-percent-wrong-way-to-define-a-method/"/>
    <updated>2014-08-18T21:44:51-07:00</updated>
    <id>http://dwhitworth.github.io/blog/2014/08/18/ruby-the-absolutely-100-percent-wrong-way-to-define-a-method</id>
    <content type="html"><![CDATA[<p>The app that I am building and maintaining contains travel and geographical information for a bunch of destinations around the World. I was tasked to build an API that would serve some JSON info from our database to an iOS app requesting it. Simple enough. In the database that I created everything was pretty simply and logically named (so I thought), but I knew ahead of time that there was going to be some data transformation, so I decide to implement <a href="https://github.com/rails-api/active_model_serializers">ActiveModel::Serializers</a> for easy encapsulation and customization of the JSON object that I was delivering via said API.</p>

<p>Without changing anything, my app would deliver a JSON object that looked something like this:</p>

<p><code>{ &ldquo;id&rdquo;: 1, &ldquo;description&rdquo;: &ldquo;This is a description&rdquo;, &ldquo;latitude&rdquo;: &ldquo;33.9425째 N&rdquo;, longitude: &ldquo;33.9425째 N&rdquo; }</code></p>

<!-- more -->


<p>Surely, the names couldn&rsquo;t be that different in the iOS client that needed the data? Even so, it&rsquo;s pretty easy to transform data in ActiveModel::Serializer by defining custom attributes. Say you wanted to change the name of &ldquo;description&rdquo; to &ldquo;info&rdquo; in your JSON, you would just do this in your serializer:
``` ruby
class AreaSerializer &lt; ActiveModel::Serializer
  attributes :info</p>

<p>  def info</p>

<pre><code>object.description
</code></pre>

<p>  end</p>

<p>end
```
Easy, right? Well, whoever created the iOS app decided that they wanted the JSON object to look something like this:</p>

<p><code>
{ &ldquo;Area info page (400 characters)&rdquo;: &ldquo;This is a description&rdquo;, &ldquo;center latitude&rdquo;: &ldquo;33.9425째 N&rdquo;, &ldquo;center longitude&rdquo;: &ldquo;33.9425째 N&rdquo; }</p>

<p>It couldn&rsquo;t be changed on the iOS side, as that app didn&rsquo;t have any full-time Objective-C devs maintaining it, so the, ummm&hellip;, flexibility had to be on my end. Well, not only is that naming convention completely strange and eff&rsquo;d up, how do I make a method name with spaces in it (also completely wrong and eff&rsquo;d up)? Basically I need the above code to look like this (which doesn&rsquo;t work, btw):</p>

<p>``` ruby
class AreaSerializer &lt; ActiveModel::Serializer
  attributes :&ldquo;Area info page (400 characters)&rdquo;</p>

<p>  def Area info page (400 characters)</p>

<pre><code>object.description
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>One of the reasons I love Ruby (and one of the reasons you should be really careful, since Ruby lets you get away with shit like this)&hellip; define_method! Here&rsquo;s how you make really awful looking method names (kids, don&rsquo;t try this at home):</p>

<p>``` ruby
class AreaSerializer &lt; ActiveModel::Serializer
  attributes :&ldquo;Area info page (400 characters)&rdquo;</p>

<p>  define_method(&ldquo;Area info page (400 characters)&rdquo;) do</p>

<pre><code>object.description
</code></pre>

<p>  end</p>

<p>end
```
And there you go! If you need to write some really horrible looking method names in Ruby, that&rsquo;s how you do it. Until next time&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SQL Is Your Friend]]></title>
    <link href="http://dwhitworth.github.io/blog/2014/04/26/sql-is-your-friend/"/>
    <updated>2014-04-26T16:36:52-07:00</updated>
    <id>http://dwhitworth.github.io/blog/2014/04/26/sql-is-your-friend</id>
    <content type="html"><![CDATA[<p>Our final project for MakerSquare was crowd-funding platform for public dares, challenges and acts of kindness. You can check it out here: <a href="http://we-dare-you.herokuapp.com">we-dare-you.herokuapp.com</a>. Every dare had multiple monetary contributions and we would sum up those contributions via a &ldquo;pot_size&rdquo; method. <!-- more --></p>

<p>When summing up multiple elements in an array, our go to method is Ruby&rsquo;s <code>inject</code> method, but sometimes we forget that SQL has some built in functionality that may be faster and ease the load on memory.</p>

<p>We had 8 models with quite a few associations, but let&rsquo;s concentrate on two models:</p>

<p>```ruby
class Dare &lt; ActiveRecord::Base
  has_many :contributions
  # &hellip;
end</p>

<p>class Contribution &lt; ActiveRecord::Base
  belongs_to :dare
  # &hellip;
end
```</p>

<p>So, to get a pot size for a specific dare, we made a method that looked something like this:</p>

<p><code>ruby
def pot_size
  self.contributions.inject(0) {| total, contribution | total + contribution.amount }.to_f / 100
end
</code></p>

<p>This should be refactored to:</p>

<p><code>ruby
def pot_size
  self.contributions.map(&amp;:amount).inject(:+).to_f / 100
end
</code></p>

<p>Using this method, we use the has_many association to get all the contributions for a specific dare. The SQL generated looks something like this:</p>

<p><code>SELECT &ldquo;amount&rdquo;.* FROM &ldquo;contributions&rdquo; WHERE &ldquo;contributions&rdquo;.&ldquo;dare_id&rdquo; = &lt;dare_id></code></p>

<p>I seeded a database with 100,000 test contributions and the above method took 1.6 seconds and change. The SQL statement above is finding all the contributions and putting them into memory before adding up the amounts.</p>

<p>A much more efficient way is to use SQL to do the work of summing the amounts. It will be much faster and use much less memory. We can refactor the &ldquo;pot_size&rdquo; method to look more like this:</p>

<p><code>ruby
def pot_size
  self.contributions.sum(:amount).to_f / 100
end
</code></p>

<p>It generated SQL that looked like this:</p>

<p><code>SELECT SUM(&ldquo;contributions&rdquo;.&ldquo;amount&rdquo;) AS sum_id FROM &ldquo;contributions&rdquo; WHERE &ldquo;contributions&rdquo;.&ldquo;dare_id&rdquo; = &lt;dare_id></code></p>

<p>Using the above method, we avoid pulling all those records into memory and let SQL sum up the amounts in one step. The above method took 17ms!</p>

<p>The moral of the story is you don&rsquo;t <em>always</em> have to use Ruby methods when manipulating your ActiveRecord objects, sometimes good old SQL is faster and uses less memory.</p>
]]></content>
  </entry>
  
</feed>
