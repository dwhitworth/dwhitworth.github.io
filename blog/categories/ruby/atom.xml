<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Donovan Whitworth]]></title>
  <link href="http://dwhitworth.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://dwhitworth.github.io/"/>
  <updated>2014-08-18T22:22:43-07:00</updated>
  <id>http://dwhitworth.github.io/</id>
  <author>
    <name><![CDATA[Donovan Whitworth]]></name>
    <email><![CDATA[donovan.whitworth@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby: The absolutely 100% wrong way to define a method]]></title>
    <link href="http://dwhitworth.github.io/blog/2014/08/18/ruby-the-absolutely-100-percent-wrong-way-to-define-a-method/"/>
    <updated>2014-08-18T21:44:51-07:00</updated>
    <id>http://dwhitworth.github.io/blog/2014/08/18/ruby-the-absolutely-100-percent-wrong-way-to-define-a-method</id>
    <content type="html"><![CDATA[<p>The app that I am building and maintaining contains travel and geographical information for a bunch of destinations around the World. I was tasked to build an API for our database that would serve some JSON to an iOS app. Simple enough. In the database that I created everything was pretty simply and logically named (so I thought), but I knew ahead of time that there was going to be some data transformation, so I decide to implement <a href="https://github.com/rails-api/active_model_serializers">ActiveModel::Serializers</a> for easy encapsulation and customization of the JSON object that I was delivering via my API.</p>

<p>Without doing much, my app would deliver a JSON object that looked something like this:</p>

<p><code>{ &ldquo;id&rdquo;: 1, &ldquo;description&rdquo;: &ldquo;This is a description&rdquo;, &ldquo;latitude&rdquo;: &ldquo;33.9425째 N&rdquo;, longitude: &ldquo;33.9425째 N&rdquo; }</code></p>

<!-- more -->


<p>Surely, the names couldn&rsquo;t be that different in the iOS client that needed the data? Even so, it&rsquo;s pretty easy to transform data in ActiveModel::Serializer by defining custom attributes. Say you wanted to change the name of &ldquo;description&rdquo; to info in your JSON, you would just do this in your serializer:
``` ruby
class AreaSerializer &lt; ActiveModel::Serializer
  attributes :info</p>

<p>  def info</p>

<pre><code>object.description
</code></pre>

<p>  end</p>

<p>end
```
Easy, right? Well, whoever created the iOS app decided that they wanted the JSON object to look something like this:</p>

<p><code>
{ &ldquo;Area info page (400 characters)&rdquo;: &ldquo;This is a description&rdquo;, &ldquo;center latitude&rdquo;: &ldquo;33.9425째 N&rdquo;, &ldquo;center longitude&rdquo;: &ldquo;33.9425째 N&rdquo; }</p>

<p>It couldn&rsquo;t be changed, as the iOS app was using legacy code that no one wants to change, so the ummm&hellip; flexibility had to done on my end. Well, not only is that naming convention completely strange and eff&rsquo;d up, how do I make a method name with spaces in it (also completely wrong and eff&rsquo;d up)? Basically I need the above code to look like this:</p>

<p>``` ruby
class AreaSerializer &lt; ActiveModel::Serializer
  attributes :&ldquo;Area info page (400 characters)&rdquo;</p>

<p>  def Area info page (400 characters)</p>

<pre><code>object.description
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>One of the reasons I love Ruby (and one of the reasons you should be really careful, since Ruby lets you get away with shit like this)&hellip; define_method! Here&rsquo;s how you make really awful looking method names (kids, don&rsquo;t try this at home):</p>

<p>``` ruby
class AreaSerializer &lt; ActiveModel::Serializer
  attributes :&ldquo;Area info page (400 characters)&rdquo;</p>

<p>  define_method(&ldquo;Area info page (400 characters)&rdquo;) do</p>

<pre><code>object.description
</code></pre>

<p>  end</p>

<p>end
```
And there you go! If you need to write some really horrible looking method names in Ruby, that&rsquo;s how you do it. Until next time&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SQL Is Your Friend]]></title>
    <link href="http://dwhitworth.github.io/blog/2014/04/26/sql-is-your-friend/"/>
    <updated>2014-04-26T16:36:52-07:00</updated>
    <id>http://dwhitworth.github.io/blog/2014/04/26/sql-is-your-friend</id>
    <content type="html"><![CDATA[<p>Our final project for MakerSquare was crowd-funding platform for public dares, challenges and acts of kindness. You can check it out here: <a href="http://we-dare-you.herokuapp.com">we-dare-you.herokuapp.com</a>. Every dare had multiple monetary contributions and we would sum up those contributions via a &ldquo;pot_size&rdquo; method. <!-- more --></p>

<p>When summing up multiple elements in an array, our go to method is Ruby&rsquo;s <code>inject</code> method, but sometimes we forget that SQL has some built in functionality that may be faster and ease the load on memory.</p>

<p>We had 8 models with quite a few associations, but let&rsquo;s concentrate on two models:</p>

<p>```ruby
class Dare &lt; ActiveRecord::Base
  has_many :contributions
  # &hellip;
end</p>

<p>class Contribution &lt; ActiveRecord::Base
  belongs_to :dare
  # &hellip;
end
```</p>

<p>So, to get a pot size for a specific dare, we made a method that looked something like this:</p>

<p><code>ruby
def pot_size
  self.contributions.inject(0) {| total, contribution | total + contribution.amount }.to_f / 100
end
</code></p>

<p>This should be refactored to:</p>

<p><code>ruby
def pot_size
  self.contributions.map(&amp;:amount).inject(:+).to_f / 100
end
</code></p>

<p>Using this method, we use the has_many association to get all the contributions for a specific dare. The SQL generated looks something like this:</p>

<p><code>SELECT &ldquo;amount&rdquo;.* FROM &ldquo;contributions&rdquo; WHERE &ldquo;contributions&rdquo;.&ldquo;dare_id&rdquo; = &lt;dare_id></code></p>

<p>I seeded a database with 100,000 test contributions and the above method took 1.6 seconds and change. The SQL statement above is finding all the contributions and putting them into memory before adding up the amounts.</p>

<p>A much more efficient way is to use SQL to do the work of summing the amounts. It will be much faster and use much less memory. We can refactor the &ldquo;pot_size&rdquo; method to look more like this:</p>

<p><code>ruby
def pot_size
  self.contributions.sum(:amount).to_f / 100
end
</code></p>

<p>It generated SQL that looked like this:</p>

<p><code>SELECT SUM(&ldquo;contributions&rdquo;.&ldquo;amount&rdquo;) AS sum_id FROM &ldquo;contributions&rdquo; WHERE &ldquo;contributions&rdquo;.&ldquo;dare_id&rdquo; = &lt;dare_id></code></p>

<p>Using the above method, we avoid pulling all those records into memory and let SQL sum up the amounts in one step. The above method took 17ms!</p>

<p>The moral of the story is you don&rsquo;t <em>always</em> have to use Ruby methods when manipulating your ActiveRecord objects, sometimes good old SQL is faster and uses less memory.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby: counting duplicates in an array with inject]]></title>
    <link href="http://dwhitworth.github.io/blog/2014/02/16/counting-duplicates-in-an-array-with-inject/"/>
    <updated>2014-02-16T17:29:43-08:00</updated>
    <id>http://dwhitworth.github.io/blog/2014/02/16/counting-duplicates-in-an-array-with-inject</id>
    <content type="html"><![CDATA[<p>Earlier this week we were tasked with calculating the most and least popular colors, given an array of car objects. <!-- more -->We started with this array:</p>

<p><code>ruby
@cars = []
3.times { @cars &lt;&lt; Car.new('black') }
5.times { @cars &lt;&lt; Car.new('silver') }
2.times { @cars &lt;&lt; Car.new('white') }
</code></p>

<p>We needed to make methods that would return the most popular color (5 silver cars) and the least popular (2 white cars). The first thing I did was make a new array from the array of car objects (using the .map method) populated with just colors. Like this:</p>

<p><code>ruby
@colors = @cars.map { |car| car.color }
</code>
If you puts that array it would look like this:
<code>ruby
["black", "black", "black", 'silver', 'silver', 'silver', 'silver', 'silver', "white", "white"]
</code></p>

<p>So, now how do you get a count of all items in that array, incremented every time you hit a duplicate?</p>

<p>.inject</p>

<p>First, let&rsquo;s talk about .inject. Ruby docs says .inject:</p>

<blockquote><p>Combines all elements of enum by applying a binary operation, specified by a block or a symbol that names a method or operator.</p>

<p>If you specify a block, then for each element in enum the block is passed an accumulator value and the element. At the end of the iteration, the final value of memo is the return value for the method.</p></blockquote>

<p>whaahuhhh?</p>

<p>Well, let&rsquo;s break it down by using the classic example of .inject. To obtain a sum of each element in an array you could do this:
<code>ruby
[1,2,3,4,5].inject(0) { |item, element| item + element } # =&gt; 15
</code>
The argument you pass into <code>.inject(0)</code> is then passed into the <code>item</code> variable, which is then added to the first <code>element</code> in the array. Then the return value of the block is passed back into the block as <code>item</code>. This is done for each element in the array, leaving you with a sum of the numbers.</p>

<p>So, back to our array of colors. How do I turn that into <code>{&ldquo;black&rdquo; => 3, &ldquo;silver&rdquo; => 5, &ldquo;white&rdquo; => 2}</code>?</p>

<p>Well, if I use <code>Hash.new(0)</code> as the first accumulator value, that will make a new hash and the default values for each key you pass in will be 0. Then, everytime I pass a duplicate into that hash, I just increment the value for that given key, then return the entire hash back into the accumulator. Like this:</p>

<p>```ruby
@frequency = @colors.inject(Hash.new(0)) do |hash, key|</p>

<pre><code>hash[key] += 1
hash
end
</code></pre>

<p>```</p>

<p>So, for each element of the @colors array, we inject a hash with the element becoming the key, and everytime that key is passed into the block, we increment the value. Voila!
<code>
{"black" =&gt; 3, "silver" =&gt; 5, "white" =&gt; 2}
</code>
Now I can access the lowest and/or highest values in the array using the <code>min_by</code> or <code>max_by</code> methods for a hash.</p>

<p>Until next time&hellip;</p>

<blockquote><p>If you end up with a boring miserable life because you listened to your mom, your dad, your teacher, your priest, or some guy on television telling you how to do your shit, then you deserve it.</p>

<p>- Frank Zappa</p></blockquote>
]]></content>
  </entry>
  
</feed>
